<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mechanism Preview</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="js/mechanism-definitions.js?v=20260220a"></script>
    <script src="js/mechanism-canvas-renderer.js?v=20260220a"></script>
</head>

<body class="min-h-screen bg-slate-950 text-slate-100">
    <main class="mx-auto max-w-7xl p-4 sm:p-6">
        <header class="mb-6 rounded-xl border border-slate-700 bg-slate-900/80 p-4">
            <h1 class="text-2xl font-bold">Mechanism Preview</h1>
            <p class="mt-2 text-sm text-slate-300">
                Inspect curated M2 mechanism definitions before wiring them into map interactions.
            </p>
        </header>

        <section class="grid gap-4 lg:grid-cols-[320px_1fr]">
            <aside class="rounded-xl border border-slate-700 bg-slate-900/80 p-4">
                <label for="mechanismSelect" class="block text-xs font-semibold uppercase tracking-wide text-slate-300">
                    Mechanism ID
                </label>
                <select id="mechanismSelect"
                    class="mt-2 w-full rounded border border-slate-600 bg-slate-800 px-3 py-2 text-sm text-slate-100"></select>
                <p id="mechanismCount" class="mt-2 text-xs text-slate-400"></p>
            </aside>

            <section class="space-y-4">
                <article class="rounded-xl border border-slate-700 bg-slate-900/80 p-4">
                    <h2 id="definitionTitle" class="text-xl font-semibold text-white"></h2>
                    <p id="definitionSummary" class="mt-2 text-sm text-slate-300"></p>
                    <div class="mt-4 grid gap-4 md:grid-cols-2">
                        <div class="rounded border border-slate-700 bg-slate-950/70 p-3">
                            <p class="text-xs font-semibold uppercase tracking-wide text-slate-400">Step sequence</p>
                            <ol id="definitionSteps" class="mt-2 list-decimal space-y-1 pl-5 text-sm text-slate-200"></ol>
                        </div>
                        <div class="rounded border border-slate-700 bg-slate-950/70 p-3">
                            <p class="text-xs font-semibold uppercase tracking-wide text-slate-400">Cue counts</p>
                            <ul id="definitionMeta" class="mt-2 space-y-1 text-sm text-slate-200"></ul>
                        </div>
                    </div>
                </article>

                <article class="rounded-xl border border-slate-700 bg-slate-900/80 p-4">
                    <div class="flex flex-wrap items-center gap-2">
                        <button id="playPauseBtn"
                            class="rounded bg-sky-600 px-3 py-1 text-xs font-bold text-white hover:bg-sky-500"
                            type="button">Play</button>
                        <button id="resetBtn"
                            class="rounded bg-slate-700 px-3 py-1 text-xs font-bold text-white hover:bg-slate-600"
                            type="button">Reset</button>
                        <label for="durationSelect"
                            class="ml-auto text-xs font-semibold uppercase tracking-wide text-slate-400">
                            Duration
                        </label>
                        <select id="durationSelect"
                            class="rounded border border-slate-600 bg-slate-800 px-2 py-1 text-xs font-semibold text-slate-100">
                            <option value="2200">2.2s</option>
                            <option value="3000">3.0s</option>
                            <option value="3600" selected>3.6s</option>
                            <option value="4200">4.2s</option>
                        </select>
                    </div>
                    <div class="mt-3 rounded border border-slate-700 bg-slate-950 p-2">
                        <canvas id="previewCanvas" width="360" height="180" class="h-56 w-full rounded bg-slate-950 md:h-64"></canvas>
                    </div>
                    <div class="mt-2 flex items-center gap-2">
                        <label for="previewProgress"
                            class="text-xs font-semibold uppercase tracking-wide text-slate-400">Progress</label>
                        <input id="previewProgress" type="range" min="0" max="100" value="0" step="0.1"
                            class="flex-1 accent-sky-500">
                    </div>
                    <p id="previewStep" class="mt-2 text-xs text-slate-200"></p>
                    <svg id="pathPreview" viewBox="0 0 360 110"
                        class="mt-2 h-16 w-full rounded border border-slate-700 bg-slate-950">
                        <path id="previewPath" d="" fill="none" stroke="#8b5cf6" stroke-width="4" stroke-linecap="round"></path>
                        <circle id="previewMarker" cx="24" cy="84" r="6" fill="#e9d5ff"></circle>
                    </svg>
                </article>

                <article class="rounded-xl border border-slate-700 bg-slate-900/80 p-4">
                    <p class="text-xs font-semibold uppercase tracking-wide text-slate-400">Definition JSON</p>
                    <pre id="definitionJson"
                        class="mt-2 max-h-[360px] overflow-auto rounded border border-slate-700 bg-slate-950/70 p-3 text-xs text-slate-200"></pre>
                </article>
            </section>
        </section>
    </main>

    <script>
        (function initMechanismPreview() {
            const definitions = window.OrganicMapMechanismDefinitions || {};
            const canvasRenderer = window.OrganicMapCanvasRenderer || null;
            const drawMechanismCanvasFrame =
                canvasRenderer && typeof canvasRenderer.drawMechanismCanvasFrame === 'function'
                    ? canvasRenderer.drawMechanismCanvasFrame
                    : null;
            const selectCueByStep =
                canvasRenderer && typeof canvasRenderer.selectCueByStep === 'function'
                    ? canvasRenderer.selectCueByStep
                    : null;
            const getActiveStepIndex =
                canvasRenderer && typeof canvasRenderer.getActiveStepIndex === 'function'
                    ? canvasRenderer.getActiveStepIndex
                    : null;
            const parseCubicPath =
                canvasRenderer && typeof canvasRenderer.parseCubicPath === 'function'
                    ? canvasRenderer.parseCubicPath
                    : null;
            const applyArrowBend =
                canvasRenderer && typeof canvasRenderer.applyArrowBend === 'function'
                    ? canvasRenderer.applyArrowBend
                    : null;
            const sampleCurvePoints =
                canvasRenderer && typeof canvasRenderer.sampleCurvePoints === 'function'
                    ? canvasRenderer.sampleCurvePoints
                    : null;
            const collectMechanismPoints =
                canvasRenderer && typeof canvasRenderer.collectMechanismPoints === 'function'
                    ? canvasRenderer.collectMechanismPoints
                    : null;

            const animationIds = Object.keys(definitions).sort();

            const mechanismSelect = document.getElementById('mechanismSelect');
            const mechanismCount = document.getElementById('mechanismCount');
            const definitionTitle = document.getElementById('definitionTitle');
            const definitionSummary = document.getElementById('definitionSummary');
            const definitionSteps = document.getElementById('definitionSteps');
            const definitionMeta = document.getElementById('definitionMeta');
            const definitionJson = document.getElementById('definitionJson');
            const previewCanvas = document.getElementById('previewCanvas');
            const previewPath = document.getElementById('previewPath');
            const previewMarker = document.getElementById('previewMarker');
            const playPauseBtn = document.getElementById('playPauseBtn');
            const resetBtn = document.getElementById('resetBtn');
            const durationSelect = document.getElementById('durationSelect');
            const previewProgress = document.getElementById('previewProgress');
            const previewStep = document.getElementById('previewStep');

            const renderOptions = {
                fitToContent: true,
                preserveAspect: true,
                strictStepCues: true,
                fitMargin: 24,
                fitTopInset: 18,
                fitBottomInset: 20,
                fitMinScale: 0.82,
                fitMaxScale: 3.6,
                fitArrowSamples: 18,
                stabilizeFitByDefinition: true,
            };

            let currentAnimationId = null;
            let currentDefinition = null;
            let currentProgress = 0;
            let previewCanvasCtx = null;
            let rafId = null;
            let isPlaying = false;
            let cycleStart = 0;
            const definitionFitEnvelopeCache = new WeakMap();

            function inferAtomType(label) {
                const normalized = String(label || '').trim().toUpperCase();
                if (!normalized) {
                    return 'C';
                }
                if (normalized.startsWith('BR')) return 'Br';
                if (normalized.startsWith('CL')) return 'Cl';
                if (normalized.startsWith('O')) return 'O';
                if (normalized.startsWith('N')) return 'N';
                if (normalized === 'H' || normalized.startsWith('H+')) return 'H';
                if (normalized.startsWith('B')) return 'B';
                if (normalized.includes('CH') || normalized.includes('ET') || normalized.length > 2) return 'Group';
                return 'C';
            }

            function buildStepMilestones(steps) {
                const list = Array.isArray(steps) && steps.length > 0 ? steps : ['Mechanism step preview.'];
                const count = list.length;
                return list.map((text, index) => {
                    const start = index / count;
                    const end = (index + 1) / count;
                    return {
                        text,
                        index,
                        start,
                        end,
                    };
                });
            }

            function buildEnvelopeFromPoints(points) {
                if (!Array.isArray(points) || points.length < 2) {
                    return null;
                }
                let minX = Infinity;
                let maxX = -Infinity;
                let minY = Infinity;
                let maxY = -Infinity;

                points.forEach(point => {
                    if (!point) {
                        return;
                    }
                    const x = Number(point.x);
                    const y = Number(point.y);
                    if (!Number.isFinite(x) || !Number.isFinite(y)) {
                        return;
                    }
                    minX = Math.min(minX, x);
                    maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y);
                    maxY = Math.max(maxY, y);
                });

                if (!Number.isFinite(minX) || !Number.isFinite(maxX) || !Number.isFinite(minY) || !Number.isFinite(maxY)) {
                    return null;
                }

                return { minX, maxX, minY, maxY };
            }

            function mergeEnvelopes(primaryEnvelope, secondaryEnvelope) {
                if (!primaryEnvelope && !secondaryEnvelope) {
                    return null;
                }
                if (!primaryEnvelope) {
                    return secondaryEnvelope;
                }
                if (!secondaryEnvelope) {
                    return primaryEnvelope;
                }
                return {
                    minX: Math.min(primaryEnvelope.minX, secondaryEnvelope.minX),
                    maxX: Math.max(primaryEnvelope.maxX, secondaryEnvelope.maxX),
                    minY: Math.min(primaryEnvelope.minY, secondaryEnvelope.minY),
                    maxY: Math.max(primaryEnvelope.maxY, secondaryEnvelope.maxY),
                };
            }

            function getDefinitionFitEnvelope(definition) {
                if (!definition || typeof definition !== 'object') {
                    return null;
                }
                if (definitionFitEnvelopeCache.has(definition)) {
                    return definitionFitEnvelopeCache.get(definition);
                }

                const atoms = Array.isArray(definition.atoms) ? definition.atoms : [];
                const dipoles = Array.isArray(definition.dipoles) ? definition.dipoles : [];
                const lonePairs = Array.isArray(definition.lonePairs) ? definition.lonePairs : [];
                const electronMovement = Array.isArray(definition.electronMovement) ? definition.electronMovement : [];

                let points = [];
                if (collectMechanismPoints) {
                    points = collectMechanismPoints(atoms, dipoles, lonePairs, electronMovement, {
                        fitArrowSamples: renderOptions.fitArrowSamples,
                    });
                } else {
                    const pushPoint = (x, y) => {
                        const px = Number(x);
                        const py = Number(y);
                        if (Number.isFinite(px) && Number.isFinite(py)) {
                            points.push({ x: px, y: py });
                        }
                    };

                    atoms.forEach(atom => pushPoint(atom && atom.x, atom && atom.y));
                    dipoles.forEach(cue => pushPoint(cue && cue.x, cue && cue.y));
                    lonePairs.forEach(cue => pushPoint(cue && cue.x, cue && cue.y));
                    electronMovement.forEach(cue => {
                        if (!parseCubicPath || !applyArrowBend) {
                            return;
                        }
                        const parsed = parseCubicPath(cue && cue.path);
                        const curve = applyArrowBend(parsed, cue && cue.bend);
                        if (!curve) {
                            return;
                        }
                        if (sampleCurvePoints) {
                            sampleCurvePoints(curve, renderOptions.fitArrowSamples).forEach(point => {
                                pushPoint(point.x, point.y);
                            });
                            return;
                        }
                        for (let sample = 0; sample <= 14; sample += 1) {
                            const t = sample / 14;
                            const point = cubicPoint(curve, t);
                            pushPoint(point.x, point.y);
                        }
                    });
                }

                const envelope = buildEnvelopeFromPoints(points);
                definitionFitEnvelopeCache.set(definition, envelope);
                return envelope;
            }

            function selectStepScopedCues(cues, stepIndex) {
                if (!Array.isArray(cues)) {
                    return [];
                }
                return cues.filter(cue => {
                    if (!cue) {
                        return false;
                    }
                    const cueStep = cue.step === null || cue.step === undefined ? null : Number(cue.step);
                    const cueEndStep = cue.endStep === null || cue.endStep === undefined ? null : Number(cue.endStep);

                    if (cueStep === null) {
                        if (cueEndStep !== null && Number.isFinite(cueEndStep) && stepIndex > cueEndStep) {
                            return false;
                        }
                        return true;
                    }

                    if (!Number.isFinite(cueStep) || cueStep !== stepIndex) {
                        return false;
                    }

                    if (cueEndStep !== null && Number.isFinite(cueEndStep) && stepIndex > cueEndStep) {
                        return false;
                    }
                    return true;
                });
            }

            function cubicPoint(path, t) {
                const mt = 1 - t;
                const mt2 = mt * mt;
                const t2 = t * t;
                return {
                    x:
                        mt2 * mt * path.x0 +
                        3 * mt2 * t * path.x1 +
                        3 * mt * t2 * path.x2 +
                        t2 * t * path.x3,
                    y:
                        mt2 * mt * path.y0 +
                        3 * mt2 * t * path.y1 +
                        3 * mt * t2 * path.y2 +
                        t2 * t * path.y3,
                };
            }

            function cubicTangent(path, t) {
                const mt = 1 - t;
                return {
                    x:
                        3 * mt * mt * (path.x1 - path.x0) +
                        6 * mt * t * (path.x2 - path.x1) +
                        3 * t * t * (path.x3 - path.x2),
                    y:
                        3 * mt * mt * (path.y1 - path.y0) +
                        6 * mt * t * (path.y2 - path.y1) +
                        3 * t * t * (path.y3 - path.y2),
                };
            }

            function syncPreviewCanvas() {
                if (!previewCanvas) {
                    return null;
                }
                if (!previewCanvasCtx) {
                    previewCanvasCtx = previewCanvas.getContext('2d');
                }
                if (!previewCanvasCtx) {
                    return null;
                }

                const rect = previewCanvas.getBoundingClientRect();
                const width = Math.max(1, Math.round(rect.width));
                const height = Math.max(1, Math.round(rect.height));
                const dpr = window.devicePixelRatio || 1;
                const targetWidth = Math.max(1, Math.round(width * dpr));
                const targetHeight = Math.max(1, Math.round(height * dpr));

                if (previewCanvas.width !== targetWidth || previewCanvas.height !== targetHeight) {
                    previewCanvas.width = targetWidth;
                    previewCanvas.height = targetHeight;
                }
                previewCanvasCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
                return { ctx: previewCanvasCtx, width, height };
            }

            function setMarkerPosition(progressRatio) {
                const bounded = Math.max(0, Math.min(1, progressRatio));
                const pathLength = previewPath.getTotalLength();
                if (!Number.isFinite(pathLength) || pathLength <= 0) {
                    previewMarker.setAttribute('cx', '24');
                    previewMarker.setAttribute('cy', '84');
                    return;
                }
                const point = previewPath.getPointAtLength(pathLength * bounded);
                previewMarker.setAttribute('cx', point.x.toFixed(2));
                previewMarker.setAttribute('cy', point.y.toFixed(2));
            }

            function calcSceneForDefinition(definition, progressRatio) {
                if (!definition) {
                    return null;
                }

                const milestones = buildStepMilestones(definition.steps);
                const stepCount = milestones.length;
                const bounded = Math.max(0, Math.min(1, progressRatio));
                const fallbackIndex = Math.min(stepCount - 1, Math.floor(bounded * stepCount));
                const stepIndex = getActiveStepIndex
                    ? getActiveStepIndex(definition, bounded)
                    : fallbackIndex;
                const activeStep = milestones[Math.max(0, Math.min(stepCount - 1, stepIndex))] || milestones[0];
                const stepProgress = Math.max(
                    0,
                    Math.min(1, (bounded - activeStep.start) / Math.max(0.001, activeStep.end - activeStep.start)),
                );

                const atoms = selectCueByStep
                    ? selectCueByStep(definition.atoms, stepIndex, atom => atom.id)
                    : [];
                const bonds = selectCueByStep
                    ? selectCueByStep(definition.bonds, stepIndex, bond => [bond.from, bond.to].sort().join('|'))
                    : [];
                const dipoles = renderOptions.strictStepCues
                    ? selectStepScopedCues(definition.dipoles, stepIndex)
                    : (selectCueByStep ? selectCueByStep(definition.dipoles, stepIndex) : []);
                const lonePairs = renderOptions.strictStepCues
                    ? selectStepScopedCues(definition.lonePairs, stepIndex)
                    : (selectCueByStep ? selectCueByStep(definition.lonePairs, stepIndex) : []);
                const electronMovement = selectCueByStep
                    ? selectCueByStep(definition.electronMovement, stepIndex).filter(
                        cue => cue && cue.step !== null && cue.step !== undefined && Number(cue.step) === stepIndex,
                    )
                    : [];

                const atomById = new Map(atoms.map(atom => [atom.id, atom]));
                const sceneBonds = bonds
                    .map(bond => {
                        const source = atomById.get(bond.from);
                        const target = atomById.get(bond.to);
                        if (!source || !target) {
                            return null;
                        }
                        return {
                            x1: Number(source.x || 0),
                            y1: Number(source.y || 0),
                            x2: Number(target.x || 0),
                            y2: Number(target.y || 0),
                            order: Number(bond.order || 1),
                        };
                    })
                    .filter(Boolean);

                const sceneAtoms = atoms.map(atom => ({
                    x: Number(atom.x || 0),
                    y: Number(atom.y || 0),
                    label: atom.label || '',
                    type: inferAtomType(atom.label),
                    charge: Number(atom.charge || 0),
                }));

                const sceneArrows = electronMovement
                    .map(cue => {
                        if (!parseCubicPath || !applyArrowBend) {
                            return null;
                        }
                        const parsed = parseCubicPath(cue.path || '');
                        const curve = applyArrowBend(parsed, cue.bend);
                        if (!curve) {
                            return null;
                        }
                        return {
                            cue,
                            curve,
                            t: Math.max(0.08, Math.min(1, stepProgress + 0.08)),
                        };
                    })
                    .filter(Boolean);

                return {
                    stepIndex,
                    stepCount,
                    stepProgress,
                    stepText: activeStep.text,
                    atoms: sceneAtoms,
                    bonds: sceneBonds,
                    dipoles,
                    lonePairs,
                    arrows: sceneArrows,
                };
            }

            function fitSceneToCanvas(scene, width, height, options = {}, definitionEnvelope = null) {
                const padding = Number(options.padding);
                const safePadding = Number.isFinite(padding) ? padding : 24;
                const topInset = Number(options.topInset);
                const safeTopInset = Number.isFinite(topInset) ? topInset : 18;
                const bottomInset = Number(options.bottomInset);
                const safeBottomInset = Number.isFinite(bottomInset) ? bottomInset : 22;
                const minScale = Number(options.minScale);
                const safeMinScale = Number.isFinite(minScale) ? minScale : 0.82;
                const maxScale = Number(options.maxScale);
                const safeMaxScale = Number.isFinite(maxScale) ? maxScale : 3.6;
                const preserveAspect = options.preserveAspect !== false;
                const points = [];

                const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
                const pushPoint = (x, y) => {
                    const px = Number(x);
                    const py = Number(y);
                    if (Number.isFinite(px) && Number.isFinite(py)) {
                        points.push({ x: px, y: py });
                    }
                };

                scene.atoms.forEach(atom => pushPoint(atom.x, atom.y));
                scene.bonds.forEach(bond => {
                    pushPoint(bond.x1, bond.y1);
                    pushPoint(bond.x2, bond.y2);
                });
                scene.dipoles.forEach(cue => pushPoint(cue && cue.x, cue && cue.y));
                scene.lonePairs.forEach(cue => pushPoint(cue && cue.x, cue && cue.y));
                scene.arrows.forEach(arrow => {
                    const curve = arrow.curve;
                    if (!curve) {
                        return;
                    }
                    if (sampleCurvePoints) {
                        sampleCurvePoints(curve, renderOptions.fitArrowSamples).forEach(point => {
                            pushPoint(point.x, point.y);
                        });
                        return;
                    }
                    for (let sample = 0; sample <= 14; sample += 1) {
                        const t = sample / 14;
                        const point = cubicPoint(curve, t);
                        pushPoint(point.x, point.y);
                    }
                });

                const sceneEnvelope = buildEnvelopeFromPoints(points);
                const envelope = mergeEnvelopes(definitionEnvelope, sceneEnvelope);

                if (!envelope) {
                    return {
                        scaleX: 1,
                        scaleY: 1,
                        offsetX: width / 2 - 180,
                        offsetY: height / 2 - 90,
                    };
                }

                const contentWidth = Math.max(1, envelope.maxX - envelope.minX);
                const contentHeight = Math.max(1, envelope.maxY - envelope.minY);
                const availableWidth = Math.max(1, width - safePadding * 2);
                const availableHeight = Math.max(1, height - safeTopInset - safeBottomInset);

                const rawScaleX = availableWidth / contentWidth;
                const rawScaleY = availableHeight / contentHeight;
                const scaleX = preserveAspect
                    ? clamp(Math.min(rawScaleX, rawScaleY), safeMinScale, safeMaxScale)
                    : clamp(rawScaleX, safeMinScale, safeMaxScale);
                const scaleY = preserveAspect
                    ? scaleX
                    : clamp(rawScaleY, safeMinScale, safeMaxScale);

                const targetWidth = contentWidth * scaleX;
                const targetHeight = contentHeight * scaleY;
                const offsetX = safePadding + (availableWidth - targetWidth) / 2 - envelope.minX * scaleX;
                const offsetY = safeTopInset + (availableHeight - targetHeight) / 2 - envelope.minY * scaleY;

                return { scaleX, scaleY, offsetX, offsetY };
            }

            function drawSceneArrow(ctx, arrow, labelRow) {
                const { curve, t, cue } = arrow;
                const endPoint = cubicPoint(curve, t);
                const tangent = cubicTangent(curve, t);
                const angle = Math.atan2(tangent.y, tangent.x);

                ctx.save();
                ctx.strokeStyle = '#f59e0b';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 3]);
                ctx.beginPath();
                ctx.moveTo(curve.x0, curve.y0);
                ctx.bezierCurveTo(curve.x1, curve.y1, curve.x2, curve.y2, endPoint.x, endPoint.y);
                ctx.stroke();
                ctx.setLineDash([]);

                const arrowSize = 7;
                ctx.beginPath();
                ctx.moveTo(endPoint.x, endPoint.y);
                ctx.lineTo(
                    endPoint.x - arrowSize * Math.cos(angle - Math.PI / 6),
                    endPoint.y - arrowSize * Math.sin(angle - Math.PI / 6),
                );
                ctx.lineTo(
                    endPoint.x - arrowSize * Math.cos(angle + Math.PI / 6),
                    endPoint.y - arrowSize * Math.sin(angle + Math.PI / 6),
                );
                ctx.closePath();
                ctx.fillStyle = '#fbbf24';
                ctx.fill();

                const electron = cubicPoint(curve, Math.max(0, Math.min(1, t - 0.08)));
                ctx.beginPath();
                ctx.arc(electron.x, electron.y, 2.2, 0, Math.PI * 2);
                ctx.fillStyle = '#fde68a';
                ctx.fill();
                ctx.restore();

                if (cue && cue.label) {
                    ctx.fillStyle = '#fde68a';
                    ctx.font = '600 8px "Segoe UI", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(String(cue.label), 180, 156 - labelRow * 11);
                }
            }

            function drawSceneFrame(scene, definition) {
                const canvasState = syncPreviewCanvas();
                if (!canvasState) {
                    return;
                }

                const { ctx, width, height } = canvasState;
                ctx.clearRect(0, 0, width, height);

                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, '#020617');
                gradient.addColorStop(1, '#0f172a');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);

                if (!scene) {
                    ctx.fillStyle = '#94a3b8';
                    ctx.font = '600 12px "Segoe UI", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('No mechanism scene available', width / 2, height / 2);
                    return;
                }

                const definitionEnvelope = renderOptions.stabilizeFitByDefinition
                    ? getDefinitionFitEnvelope(definition)
                    : null;
                const fit = fitSceneToCanvas(scene, width, height, {
                    padding: renderOptions.fitMargin,
                    topInset: renderOptions.fitTopInset,
                    bottomInset: renderOptions.fitBottomInset,
                    preserveAspect: renderOptions.preserveAspect,
                    minScale: renderOptions.fitMinScale,
                    maxScale: renderOptions.fitMaxScale,
                }, definitionEnvelope);

                ctx.save();
                ctx.translate(fit.offsetX, fit.offsetY);
                ctx.scale(fit.scaleX, fit.scaleY);

                scene.bonds.forEach(bond => {
                    if (canvasRenderer && typeof canvasRenderer.drawCanvasBond === 'function') {
                        canvasRenderer.drawCanvasBond(
                            ctx,
                            { x: bond.x1, y: bond.y1 },
                            { x: bond.x2, y: bond.y2 },
                            bond.order,
                        );
                        return;
                    }
                    ctx.beginPath();
                    ctx.moveTo(bond.x1, bond.y1);
                    ctx.lineTo(bond.x2, bond.y2);
                    ctx.strokeStyle = '#94a3b8';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });

                scene.arrows.forEach((arrow, idx) => drawSceneArrow(ctx, arrow, idx));

                scene.atoms.forEach(atom => {
                    if (canvasRenderer && typeof canvasRenderer.drawCanvasAtom === 'function') {
                        canvasRenderer.drawCanvasAtom(ctx, atom);
                        return;
                    }
                    ctx.beginPath();
                    ctx.arc(atom.x, atom.y, 8, 0, Math.PI * 2);
                    ctx.fillStyle = '#334155';
                    ctx.fill();
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '700 8px "Segoe UI", sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(atom.label || '', atom.x, atom.y);
                });

                scene.dipoles.forEach(cue => {
                    if (canvasRenderer && typeof canvasRenderer.drawCanvasDipole === 'function') {
                        canvasRenderer.drawCanvasDipole(ctx, cue);
                    }
                });

                scene.lonePairs.forEach(cue => {
                    if (canvasRenderer && typeof canvasRenderer.drawCanvasLonePair === 'function') {
                        canvasRenderer.drawCanvasLonePair(ctx, cue);
                    }
                });

                ctx.restore();

                ctx.fillStyle = 'rgba(148, 163, 184, 0.9)';
                ctx.font = '600 10px "Segoe UI", sans-serif';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText(`Step ${scene.stepIndex + 1}/${scene.stepCount}`, 10, 14);
            }

            function renderFallbackCanvas() {
                if (drawMechanismCanvasFrame && currentDefinition) {
                    drawMechanismCanvasFrame(currentDefinition, currentProgress, {
                        syncCanvas: syncPreviewCanvas,
                        fitToContent: true,
                        preserveAspect: true,
                        strictStepCues: true,
                        fitMargin: 24,
                        fitTopInset: 24,
                        fitBottomInset: 28,
                    });
                    return;
                }

                const canvasState = syncPreviewCanvas();
                if (!canvasState) {
                    return;
                }
                const { ctx, width, height } = canvasState;
                ctx.clearRect(0, 0, width, height);
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, '#020617');
                gradient.addColorStop(1, '#0f172a');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, width, height);
                ctx.fillStyle = '#94a3b8';
                ctx.font = '600 12px "Segoe UI", sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Shared canvas renderer unavailable', width / 2, height / 2);
            }

            function stopPlayback() {
                if (rafId !== null) {
                    window.cancelAnimationFrame(rafId);
                    rafId = null;
                }
                isPlaying = false;
                playPauseBtn.innerText = 'Play';
            }

            function setProgress(progressRatio, options = {}) {
                const bounded = Math.max(0, Math.min(1, progressRatio));
                currentProgress = bounded;

                if (options.updateSlider !== false) {
                    previewProgress.value = (bounded * 100).toFixed(1);
                }

                setMarkerPosition(bounded);

                if (!currentDefinition) {
                    previewStep.innerText = '';
                    renderFallbackCanvas();
                    return;
                }

                const scene = calcSceneForDefinition(currentDefinition, bounded);
                if (scene) {
                    drawSceneFrame(scene, currentDefinition);
                    previewStep.innerText = scene.stepText || 'Mechanism step preview.';
                } else {
                    previewStep.innerText = 'Mechanism step preview.';
                    renderFallbackCanvas();
                }
            }

            function renderDefinition(animationId) {
                const definition = definitions[animationId];
                if (!definition) {
                    currentAnimationId = null;
                    currentDefinition = null;
                    definitionTitle.innerText = 'No mechanism selected';
                    definitionSummary.innerText = '';
                    definitionSteps.innerHTML = '';
                    definitionMeta.innerHTML = '';
                    definitionJson.innerText = '{}';
                    previewPath.setAttribute('d', 'M 24 84 C 92 26, 268 26, 336 84');
                    setProgress(0);
                    return;
                }

                currentAnimationId = animationId;
                currentDefinition = definition;
                definitionTitle.innerText = definition.title || animationId;
                definitionSummary.innerText = definition.summary || '';

                definitionSteps.innerHTML = '';
                buildStepMilestones(definition.steps).forEach(step => {
                    const li = document.createElement('li');
                    li.innerText = step.text;
                    definitionSteps.appendChild(li);
                });

                definitionMeta.innerHTML = '';
                const cueRows = [
                    ['Atoms', Array.isArray(definition.atoms) ? definition.atoms.length : 0],
                    ['Bonds', Array.isArray(definition.bonds) ? definition.bonds.length : 0],
                    ['Dipoles', Array.isArray(definition.dipoles) ? definition.dipoles.length : 0],
                    ['Lone pairs', Array.isArray(definition.lonePairs) ? definition.lonePairs.length : 0],
                    ['Electron arrows', Array.isArray(definition.electronMovement) ? definition.electronMovement.length : 0],
                ];

                if (selectCueByStep) {
                    const initialStepArrows = selectCueByStep(definition.electronMovement, 0).length;
                    cueRows.push(['Step 1 active arrows', initialStepArrows]);
                }

                cueRows.forEach(([label, value]) => {
                    const li = document.createElement('li');
                    li.innerText = `${label}: ${value}`;
                    definitionMeta.appendChild(li);
                });

                previewPath.setAttribute('d', typeof definition.path === 'string' ? definition.path : '');
                definitionJson.innerText = JSON.stringify(definition, null, 2);
                setProgress(0);
            }

            function tick(timestamp) {
                if (!isPlaying || !currentAnimationId) {
                    return;
                }

                if (!cycleStart) {
                    cycleStart = timestamp;
                }

                const duration = Math.max(200, Number(durationSelect.value) || 3600);
                const elapsed = timestamp - cycleStart;
                const normalized = (elapsed % duration) / duration;
                setProgress(normalized);
                rafId = window.requestAnimationFrame(tick);
            }

            playPauseBtn.addEventListener('click', () => {
                if (!currentAnimationId) {
                    return;
                }
                if (isPlaying) {
                    stopPlayback();
                    return;
                }
                isPlaying = true;
                playPauseBtn.innerText = 'Pause';
                cycleStart = 0;
                rafId = window.requestAnimationFrame(tick);
            });

            resetBtn.addEventListener('click', () => {
                stopPlayback();
                setProgress(0);
            });

            durationSelect.addEventListener('change', () => {
                if (!isPlaying) {
                    return;
                }
                const duration = Math.max(200, Number(durationSelect.value) || 3600);
                cycleStart = performance.now() - currentProgress * duration;
            });

            previewProgress.addEventListener('input', event => {
                stopPlayback();
                setProgress(Number(event.target.value || 0) / 100, { updateSlider: false });
            });

            mechanismSelect.addEventListener('change', event => {
                stopPlayback();
                renderDefinition(String(event.target.value || ''));
            });

            window.addEventListener('resize', () => {
                if (currentDefinition) {
                    setProgress(currentProgress);
                }
            });

            mechanismCount.innerText = `${animationIds.length} curated mechanisms loaded`;
            mechanismSelect.innerHTML = '';
            animationIds.forEach(animationId => {
                const option = document.createElement('option');
                option.value = animationId;
                option.innerText = animationId;
                mechanismSelect.appendChild(option);
            });

            if (!animationIds.length) {
                renderDefinition(null);
                stopPlayback();
                return;
            }

            mechanismSelect.value = animationIds[0];
            renderDefinition(animationIds[0]);
        })();
    </script>
</body>

</html>
